// Copyright 2020 The Pigweed Authors
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.
#include "gtest/gtest.h"
#include "pw_protobuf/encoder.h"
#include "pw_span/span.h"
#include "pw_stream/memory_stream.h"

// These header files contain the code generated by the pw_protobuf plugin.
// They are re-generated every time the tests are built and are used by the
// tests to ensure that the interface remains consistent.
//
// The purpose of the tests in this file is primarily to verify that the
// generated C++ interface is valid rather than the correctness of the
// low-level encoder.
#include "pw_protobuf_test_protos/full_test.pwpb.h"
#include "pw_protobuf_test_protos/importer.pwpb.h"
#include "pw_protobuf_test_protos/non_pw_package.pwpb.h"
#include "pw_protobuf_test_protos/proto2.pwpb.h"
#include "pw_protobuf_test_protos/repeated.pwpb.h"

namespace pw::protobuf {
namespace {

using test::pwpb::Bool;
using test::pwpb::Enum;

namespace Bar = test::pwpb::Bar;
namespace BaseMessage = test::pwpb::BaseMessage;
namespace Crate = test::pwpb::Crate;
namespace DeviceInfo = test::pwpb::DeviceInfo;
namespace Foo = test::pwpb::Foo;
namespace IntegerMetadata = test::pwpb::IntegerMetadata;
namespace KeyValuePair = test::pwpb::KeyValuePair;
namespace Overlay = test::pwpb::Overlay;
namespace Period = test::pwpb::Period;
namespace Pigweed = test::pwpb::Pigweed;
namespace Proto = test::pwpb::Proto;
namespace RepeatedTest = test::pwpb::RepeatedTest;

namespace imported {
namespace Timestamp = ::pw::protobuf::test::imported::pwpb::Timestamp;
}  // namespace imported

TEST(Codegen, Codegen) {
  std::byte encode_buffer[Pigweed::kMaxEncodedSizeBytes +
                          DeviceInfo::kMaxEncodedSizeBytes];
  std::byte temp_buffer[Pigweed::kScratchBufferSizeBytes +
                        DeviceInfo::kMaxEncodedSizeBytes];
  stream::MemoryWriter writer(encode_buffer);

  Pigweed::StreamEncoder pigweed(writer, temp_buffer);
  ASSERT_EQ(OkStatus(), pigweed.WriteMagicNumber(73));
  ASSERT_EQ(OkStatus(), pigweed.WriteZiggy(-111));
  ASSERT_EQ(OkStatus(), pigweed.WriteErrorMessage("not a typewriter"));
  ASSERT_EQ(OkStatus(), pigweed.WriteBin(Pigweed::Protobuf::Binary::ZERO));

  {
    Pigweed::Pigweed::StreamEncoder pigweed_pigweed =
        pigweed.GetPigweedEncoder();
    ASSERT_EQ(OkStatus(), pigweed_pigweed.WriteStatus(Bool::FILE_NOT_FOUND));

    ASSERT_EQ(pigweed_pigweed.status(), OkStatus());
  }

  {
    Proto::StreamEncoder proto = pigweed.GetProtoEncoder();
    ASSERT_EQ(OkStatus(), proto.WriteBin(Proto::Binary::OFF));
    ASSERT_EQ(OkStatus(),
              proto.WritePigweedPigweedBin(Pigweed::Pigweed::Binary::ZERO));
    ASSERT_EQ(OkStatus(),
              proto.WritePigweedProtobufBin(Pigweed::Protobuf::Binary::ZERO));

    {
      Pigweed::Protobuf::Compiler::StreamEncoder meta = proto.GetMetaEncoder();
      ASSERT_EQ(OkStatus(), meta.WriteFileName("/etc/passwd"));
      ASSERT_EQ(OkStatus(),
                meta.WriteStatus(Pigweed::Protobuf::Compiler::Status::FUBAR));
    }

    {
      Pigweed::StreamEncoder nested_pigweed = proto.GetPigweedEncoder();
      ASSERT_EQ(OkStatus(),
                nested_pigweed.WriteErrorMessage("here we go again"));
      ASSERT_EQ(OkStatus(), nested_pigweed.WriteMagicNumber(616));

      {
        DeviceInfo::StreamEncoder device_info =
            nested_pigweed.GetDeviceInfoEncoder();

        {
          KeyValuePair::StreamEncoder attributes =
              device_info.GetAttributesEncoder();
          ASSERT_EQ(OkStatus(), attributes.WriteKey("version"));
          ASSERT_EQ(OkStatus(), attributes.WriteValue("5.3.1"));
        }

        {
          KeyValuePair::StreamEncoder attributes =
              device_info.GetAttributesEncoder();
          ASSERT_EQ(OkStatus(), attributes.WriteKey("chip"));
          ASSERT_EQ(OkStatus(), attributes.WriteValue("left-soc"));
        }

        ASSERT_EQ(OkStatus(),
                  device_info.WriteStatus(DeviceInfo::DeviceStatus::PANIC));
      }
    }
  }

  for (int i = 0; i < 5; ++i) {
    Proto::ID::StreamEncoder id = pigweed.GetIdEncoder();
    ASSERT_EQ(OkStatus(), id.WriteId(5 * i * i + 3 * i + 49));
  }

  // clang-format off
  constexpr uint8_t expected_proto[] = {
    // pigweed.magic_number
    0x08, 0x49,
    // pigweed.ziggy
    0x10, 0xdd, 0x01,
    // pigweed.error_message
    0x2a, 0x10, 'n', 'o', 't', ' ', 'a', ' ',
    't', 'y', 'p', 'e', 'w', 'r', 'i', 't', 'e', 'r',
    // pigweed.bin
    0x40, 0x01,
    // pigweed.pigweed
    0x3a, 0x02,
    // pigweed.pigweed.status
    0x08, 0x02,
    // pigweed.proto
    0x4a, 0x56,
    // pigweed.proto.bin
    0x10, 0x00,
    // pigweed.proto.pigweed_pigweed_bin
    0x18, 0x00,
    // pigweed.proto.pigweed_protobuf_bin
    0x20, 0x01,
    // pigweed.proto.meta
    0x2a, 0x0f,
    // pigweed.proto.meta.file_name
    0x0a, 0x0b, '/', 'e', 't', 'c', '/', 'p', 'a', 's', 's', 'w', 'd',
    // pigweed.proto.meta.status
    0x10, 0x02,
    // pigweed.proto.nested_pigweed
    0x0a, 0x3d,
    // pigweed.proto.nested_pigweed.error_message
    0x2a, 0x10, 'h', 'e', 'r', 'e', ' ', 'w', 'e', ' ',
    'g', 'o', ' ', 'a', 'g', 'a', 'i', 'n',
    // pigweed.proto.nested_pigweed.magic_number
    0x08, 0xe8, 0x04,
    // pigweed.proto.nested_pigweed.device_info
    0x32, 0x26,
    // pigweed.proto.nested_pigweed.device_info.attributes[0]
    0x22, 0x10,
    // pigweed.proto.nested_pigweed.device_info.attributes[0].key
    0x0a, 0x07, 'v', 'e', 'r', 's', 'i', 'o', 'n',
    // pigweed.proto.nested_pigweed.device_info.attributes[0].value
    0x12, 0x05, '5', '.', '3', '.', '1',
    // pigweed.proto.nested_pigweed.device_info.attributes[1]
    0x22, 0x10,
    // pigweed.proto.nested_pigweed.device_info.attributes[1].key
    0x0a, 0x04, 'c', 'h', 'i', 'p',
    // pigweed.proto.nested_pigweed.device_info.attributes[1].value
    0x12, 0x08, 'l', 'e', 'f', 't', '-', 's', 'o', 'c',
    // pigweed.proto.nested_pigweed.device_info.status
    0x18, 0x03,
    // pigweed.id[0]
    0x52, 0x02,
    // pigweed.id[0].id
    0x08, 0x31,
    // pigweed.id[1]
    0x52, 0x02,
    // pigweed.id[1].id
    0x08, 0x39,
    // pigweed.id[2]
    0x52, 0x02,
    // pigweed.id[2].id
    0x08, 0x4b,
    // pigweed.id[3]
    0x52, 0x02,
    // pigweed.id[3].id
    0x08, 0x67,
    // pigweed.id[4]
    0x52, 0x03,
    // pigweed.id[4].id
    0x08, 0x8d, 0x01
  };
  // clang-format on

  ConstByteSpan result = writer.WrittenData();
  ASSERT_EQ(pigweed.status(), OkStatus());
  EXPECT_EQ(result.size(), sizeof(expected_proto));
  EXPECT_EQ(std::memcmp(result.data(), expected_proto, sizeof(expected_proto)),
            0);
}

TEST(Codegen, RecursiveSubmessage) {
  // 12 here represents the longest name. Note that all field structure is taken
  // care of, we just have to multiply by how many crates we're encoding, ie. 4.
  std::byte encode_buffer[(Crate::kMaxEncodedSizeBytes + 12) * 4];

  Crate::MemoryEncoder biggest_crate(encode_buffer);
  ASSERT_EQ(OkStatus(), biggest_crate.WriteName("Huge crate"));

  {
    Crate::StreamEncoder medium_crate = biggest_crate.GetSmallerCratesEncoder();
    ASSERT_EQ(OkStatus(), medium_crate.WriteName("Medium crate"));
    {
      Crate::StreamEncoder small_crate = medium_crate.GetSmallerCratesEncoder();
      ASSERT_EQ(OkStatus(), small_crate.WriteName("Small crate"));
    }
    {
      Crate::StreamEncoder tiny_crate = medium_crate.GetSmallerCratesEncoder();
      ASSERT_EQ(OkStatus(), tiny_crate.WriteName("Tiny crate"));
    }
  }

  // clang-format off
  constexpr uint8_t expected_proto[] = {
    // crate.name
    0x0a, 0x0a, 'H', 'u', 'g', 'e', ' ', 'c', 'r', 'a', 't', 'e',
    // crate.smaller_crate[0]
    0x12, 0x2b,
    // crate.smaller_crate[0].name
    0x0a, 0x0c, 'M', 'e', 'd', 'i', 'u', 'm', ' ', 'c', 'r', 'a', 't', 'e',
    // crate.smaller_crate[0].smaller_crate[0]
    0x12, 0x0d,
    // crate.smaller_crate[0].smaller_crate[0].name
    0x0a, 0x0b, 'S', 'm', 'a', 'l', 'l', ' ', 'c', 'r', 'a', 't', 'e',
    // crate.smaller_crate[0].smaller_crate[1]
    0x12, 0x0c,
    // crate.smaller_crate[0].smaller_crate[1].name
    0x0a, 0x0a, 'T', 'i', 'n', 'y', ' ', 'c', 'r', 'a', 't', 'e',
  };
  // clang-format on

  ConstByteSpan result(biggest_crate);
  ASSERT_EQ(biggest_crate.status(), OkStatus());
  EXPECT_EQ(result.size(), sizeof(expected_proto));
  EXPECT_EQ(std::memcmp(result.data(), expected_proto, sizeof(expected_proto)),
            0);
}

TEST(CodegenRepeated, NonPackedScalar) {
  std::byte encode_buffer[RepeatedTest::kMaxEncodedSizeBytes];

  stream::MemoryWriter writer(encode_buffer);
  RepeatedTest::StreamEncoder repeated_test(writer, ByteSpan());
  for (int i = 0; i < 4; ++i) {
    ASSERT_EQ(OkStatus(), repeated_test.WriteUint32s(i * 16));
  }

  for (int i = 0; i < 4; ++i) {
    ASSERT_EQ(OkStatus(), repeated_test.WriteFixed32s(i * 16));
  }

  // clang-format off
  constexpr uint8_t expected_proto[] = {
    // uint32s[], v={0, 16, 32, 48}
    0x08, 0x00,
    0x08, 0x10,
    0x08, 0x20,
    0x08, 0x30,
    // fixed32s[]. v={0, 16, 32, 48}
    0x35, 0x00, 0x00, 0x00, 0x00,
    0x35, 0x10, 0x00, 0x00, 0x00,
    0x35, 0x20, 0x00, 0x00, 0x00,
    0x35, 0x30, 0x00, 0x00, 0x00,
  };
  // clang-format on

  ConstByteSpan result = writer.WrittenData();
  ASSERT_EQ(repeated_test.status(), OkStatus());
  EXPECT_EQ(result.size(), sizeof(expected_proto));
  EXPECT_EQ(std::memcmp(result.data(), expected_proto, sizeof(expected_proto)),
            0);
}

TEST(CodegenRepeated, PackedScalar) {
  std::byte encode_buffer[RepeatedTest::kMaxEncodedSizeBytes];

  stream::MemoryWriter writer(encode_buffer);
  RepeatedTest::StreamEncoder repeated_test(writer, ByteSpan());
  constexpr uint32_t values[] = {0, 16, 32, 48};
  ASSERT_EQ(OkStatus(), repeated_test.WriteUint32s(values));
  ASSERT_EQ(OkStatus(), repeated_test.WriteFixed32s(values));

  // clang-format off
  constexpr uint8_t expected_proto[] = {
    // uint32s[], v={0, 16, 32, 48}
    0x0a, 0x04,
    0x00,
    0x10,
    0x20,
    0x30,
    // fixed32s[]. v={0, 16, 32, 48}
    0x32, 0x10,
    0x00, 0x00, 0x00, 0x00,
    0x10, 0x00, 0x00, 0x00,
    0x20, 0x00, 0x00, 0x00,
    0x30, 0x00, 0x00, 0x00,
  };
  // clang-format on

  ConstByteSpan result = writer.WrittenData();
  ASSERT_EQ(repeated_test.status(), OkStatus());
  EXPECT_EQ(result.size(), sizeof(expected_proto));
  EXPECT_EQ(std::memcmp(result.data(), expected_proto, sizeof(expected_proto)),
            0);
}

TEST(CodegenRepeated, PackedBool) {
  std::byte encode_buffer[RepeatedTest::kMaxEncodedSizeBytes];

  stream::MemoryWriter writer(encode_buffer);
  RepeatedTest::StreamEncoder repeated_test(writer, ByteSpan());
  constexpr bool values[] = {true, false, true, true, false};
  ASSERT_EQ(OkStatus(), repeated_test.WriteBools(span(values)));

  // clang-format off
  constexpr uint8_t expected_proto[] = {
    // bools[], v={true, false, true, true, false}
    0x3a, 0x05, 0x01, 0x00, 0x01, 0x01, 0x00,
  };
  // clang-format on

  ConstByteSpan result = writer.WrittenData();
  ASSERT_EQ(repeated_test.status(), OkStatus());
  EXPECT_EQ(result.size(), sizeof(expected_proto));
  EXPECT_EQ(std::memcmp(result.data(), expected_proto, sizeof(expected_proto)),
            0);
}

TEST(CodegenRepeated, PackedScalarVector) {
  std::byte encode_buffer[RepeatedTest::kMaxEncodedSizeBytes];

  stream::MemoryWriter writer(encode_buffer);
  RepeatedTest::StreamEncoder repeated_test(writer, ByteSpan());
  const pw::Vector<uint32_t, 4> values = {0, 16, 32, 48};
  ASSERT_EQ(OkStatus(), repeated_test.WriteUint32s(values));
  ASSERT_EQ(OkStatus(), repeated_test.WriteFixed32s(values));

  // clang-format off
  constexpr uint8_t expected_proto[] = {
    // uint32s[], v={0, 16, 32, 48}
    0x0a, 0x04,
    0x00,
    0x10,
    0x20,
    0x30,
    // fixed32s[]. v={0, 16, 32, 48}
    0x32, 0x10,
    0x00, 0x00, 0x00, 0x00,
    0x10, 0x00, 0x00, 0x00,
    0x20, 0x00, 0x00, 0x00,
    0x30, 0x00, 0x00, 0x00,
  };
  // clang-format on

  ConstByteSpan result = writer.WrittenData();
  ASSERT_EQ(repeated_test.status(), OkStatus());
  EXPECT_EQ(result.size(), sizeof(expected_proto));
  EXPECT_EQ(std::memcmp(result.data(), expected_proto, sizeof(expected_proto)),
            0);
}

TEST(CodegenRepeated, PackedEnum) {
  std::byte encode_buffer[RepeatedTest::kMaxEncodedSizeBytes];

  stream::MemoryWriter writer(encode_buffer);
  RepeatedTest::StreamEncoder repeated_test(writer, ByteSpan());
  constexpr Enum values[] = {Enum::RED, Enum::GREEN, Enum::AMBER, Enum::RED};
  ASSERT_EQ(repeated_test.WriteEnums(span(values)), OkStatus());

  // clang-format off
  constexpr uint8_t expected_proto[] = {
    // enums[], v={RED, GREEN, AMBER, RED}
    0x4a, 0x04, 0x00, 0x02, 0x01, 0x00
  };
  // clang-format on

  ConstByteSpan result = writer.WrittenData();
  ASSERT_EQ(repeated_test.status(), OkStatus());
  EXPECT_EQ(result.size(), sizeof(expected_proto));
  EXPECT_EQ(std::memcmp(result.data(), expected_proto, sizeof(expected_proto)),
            0);
}

TEST(CodegenRepeated, PackedEnumVector) {
  std::byte encode_buffer[RepeatedTest::kMaxEncodedSizeBytes];

  stream::MemoryWriter writer(encode_buffer);
  RepeatedTest::StreamEncoder repeated_test(writer, ByteSpan());
  const pw::Vector<Enum, 4> values = {
      Enum::RED, Enum::GREEN, Enum::AMBER, Enum::RED};
  ASSERT_EQ(repeated_test.WriteEnums(values), OkStatus());

  // clang-format off
  constexpr uint8_t expected_proto[] = {
    // enums[], v={RED, GREEN, AMBER, RED}
    0x4a, 0x04, 0x00, 0x02, 0x01, 0x00
  };
  // clang-format on

  ConstByteSpan result = writer.WrittenData();
  ASSERT_EQ(repeated_test.status(), OkStatus());
  EXPECT_EQ(result.size(), sizeof(expected_proto));
  EXPECT_EQ(std::memcmp(result.data(), expected_proto, sizeof(expected_proto)),
            0);
}

TEST(CodegenRepeated, NonScalar) {
  std::byte encode_buffer[RepeatedTest::kMaxEncodedSizeBytes];

  stream::MemoryWriter writer(encode_buffer);
  RepeatedTest::StreamEncoder repeated_test(writer, ByteSpan());
  constexpr const char* strings[] = {"the", "quick", "brown", "fox"};
  for (const char* s : strings) {
    ASSERT_EQ(OkStatus(), repeated_test.WriteStrings(s));
  }

  constexpr uint8_t expected_proto[] = {
      0x1a, 0x03, 't', 'h', 'e', 0x1a, 0x5, 'q',  'u', 'i', 'c', 'k',
      0x1a, 0x5,  'b', 'r', 'o', 'w',  'n', 0x1a, 0x3, 'f', 'o', 'x'};
  ConstByteSpan result = writer.WrittenData();
  ASSERT_EQ(repeated_test.status(), OkStatus());
  EXPECT_EQ(result.size(), sizeof(expected_proto));
  EXPECT_EQ(std::memcmp(result.data(), expected_proto, sizeof(expected_proto)),
            0);
}

TEST(CodegenRepeated, Message) {
  std::byte encode_buffer[RepeatedTest::kMaxEncodedSizeBytes];

  RepeatedTest::MemoryEncoder repeated_test(encode_buffer);
  for (int i = 0; i < 3; ++i) {
    auto structs = repeated_test.GetStructsEncoder();
    ASSERT_EQ(OkStatus(), structs.WriteOne(i * 1));
    ASSERT_EQ(OkStatus(), structs.WriteTwo(i * 2));
  }

  // clang-format off
  constexpr uint8_t expected_proto[] = {
    0x2a, 0x04, 0x08, 0x00, 0x10, 0x00, 0x2a, 0x04, 0x08,
    0x01, 0x10, 0x02, 0x2a, 0x04, 0x08, 0x02, 0x10, 0x04};
  // clang-format on

  ConstByteSpan result(repeated_test);
  ASSERT_EQ(repeated_test.status(), OkStatus());
  EXPECT_EQ(result.size(), sizeof(expected_proto));
  EXPECT_EQ(std::memcmp(result.data(), expected_proto, sizeof(expected_proto)),
            0);
}

TEST(Codegen, Proto2) {
  std::byte encode_buffer[Foo::kMaxEncodedSizeBytes];

  Foo::MemoryEncoder foo(encode_buffer);
  ASSERT_EQ(OkStatus(), foo.WriteInteger(3));

  {
    constexpr std::byte data[] = {
        std::byte(0xde), std::byte(0xad), std::byte(0xbe), std::byte(0xef)};
    Bar::StreamEncoder bar = foo.GetBarEncoder();
    ASSERT_EQ(OkStatus(), bar.WriteData(data));
  }

  constexpr uint8_t expected_proto[] = {
      0x08, 0x03, 0x1a, 0x06, 0x0a, 0x04, 0xde, 0xad, 0xbe, 0xef};

  ConstByteSpan result(foo);
  ASSERT_EQ(foo.status(), OkStatus());
  EXPECT_EQ(result.size(), sizeof(expected_proto));
  EXPECT_EQ(std::memcmp(result.data(), expected_proto, sizeof(expected_proto)),
            0);
}

TEST(Codegen, Import) {
  std::byte encode_buffer[Period::kMaxEncodedSizeBytes];

  Period::MemoryEncoder period(encode_buffer);
  {
    imported::Timestamp::StreamEncoder start = period.GetStartEncoder();
    ASSERT_EQ(OkStatus(), start.WriteSeconds(1589501793));
    ASSERT_EQ(OkStatus(), start.WriteNanoseconds(511613110));
  }

  {
    imported::Timestamp::StreamEncoder end = period.GetEndEncoder();
    ASSERT_EQ(OkStatus(), end.WriteSeconds(1589501841));
    ASSERT_EQ(OkStatus(), end.WriteNanoseconds(490367432));
  }

  EXPECT_EQ(period.status(), OkStatus());
}

TEST(Codegen, NonPigweedPackage) {
  namespace Packed = ::non::pigweed::package::name::pwpb::Packed;

  std::byte encode_buffer[Packed::kMaxEncodedSizeBytes];
  std::array<const int64_t, 2> repeated = {0, 1};
  stream::MemoryWriter writer(encode_buffer);
  Packed::StreamEncoder packed(writer, ByteSpan());
  ASSERT_EQ(OkStatus(), packed.WriteRep(span<const int64_t>(repeated)));
  ASSERT_EQ(OkStatus(), packed.WritePacked("packed"));

  EXPECT_EQ(packed.status(), OkStatus());
}

TEST(Codegen, MemoryToStreamConversion) {
  std::byte encode_buffer[IntegerMetadata::kMaxEncodedSizeBytes];
  IntegerMetadata::MemoryEncoder metadata(encode_buffer);
  IntegerMetadata::StreamEncoder& streamed_metadata = metadata;
  EXPECT_EQ(streamed_metadata.WriteBits(3), OkStatus());

  constexpr uint8_t expected_proto[] = {0x08, 0x03};

  ConstByteSpan result(metadata);
  ASSERT_EQ(metadata.status(), OkStatus());
  EXPECT_EQ(result.size(), sizeof(expected_proto));
  EXPECT_EQ(std::memcmp(result.data(), expected_proto, sizeof(expected_proto)),
            0);
}

TEST(Codegen, OverlayConversion) {
  std::byte encode_buffer[BaseMessage::kMaxEncodedSizeBytes +
                          Overlay::kMaxEncodedSizeBytes];
  BaseMessage::MemoryEncoder base(encode_buffer);
  Overlay::StreamEncoder& overlay =
      StreamEncoderCast<Overlay::StreamEncoder>(base);
  EXPECT_EQ(overlay.WriteHeight(15), OkStatus());
  EXPECT_EQ(base.WriteLength(7), OkStatus());

  constexpr uint8_t expected_proto[] = {0x10, 0x0f, 0x08, 0x07};

  ConstByteSpan result(base);
  ASSERT_EQ(base.status(), OkStatus());
  EXPECT_EQ(result.size(), sizeof(expected_proto));
  EXPECT_EQ(std::memcmp(result.data(), expected_proto, sizeof(expected_proto)),
            0);
}

}  // namespace
}  // namespace pw::protobuf
