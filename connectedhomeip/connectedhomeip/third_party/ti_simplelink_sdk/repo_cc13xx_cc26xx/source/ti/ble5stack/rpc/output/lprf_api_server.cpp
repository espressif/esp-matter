/*
 * Generated by erpcgen 1.7.4 on Thu Jun  3 17:44:56 2021.
 *
 * AUTOGENERATED - DO NOT EDIT
 */


#include "lprf_api_server.h"
#include <new>
#include "erpc_port.h"
#include "erpc_manually_constructed.h"

#if 10704 != ERPC_VERSION_NUMBER
#error "The generated shim code version is different to the rest of eRPC code."
#endif

using namespace erpc;
using namespace std;

#if ERPC_NESTED_CALLS_DETECTION
extern bool nestingDetection;
#endif

static ManuallyConstructed<BLEmesh_api_service> s_BLEmesh_api_service;


//! @brief Function to read struct bt_mesh_prov_raw
static void read_bt_mesh_prov_raw_struct(erpc::Codec * codec, bt_mesh_prov_raw * data);

//! @brief Function to read struct bt_mesh_comp_raw
static void read_bt_mesh_comp_raw_struct(erpc::Codec * codec, bt_mesh_comp_raw * data);

//! @brief Function to read struct bt_mesh_elem_raw
static void read_bt_mesh_elem_raw_struct(erpc::Codec * codec, bt_mesh_elem_raw * data);

//! @brief Function to read struct bt_mesh_model_pub_raw
static void read_bt_mesh_model_pub_raw_struct(erpc::Codec * codec, bt_mesh_model_pub_raw * data);

//! @brief Function to read struct net_buf_simple_raw
static void read_net_buf_simple_raw_struct(erpc::Codec * codec, net_buf_simple_raw * data);

//! @brief Function to read struct bt_mesh_model_raw
static void read_bt_mesh_model_raw_struct(erpc::Codec * codec, bt_mesh_model_raw * data);

//! @brief Function to read struct bt_mesh_model_cb_raw
static void read_bt_mesh_model_cb_raw_struct(erpc::Codec * codec, bt_mesh_model_cb_raw * data);

//! @brief Function to read struct bt_mesh_model_op_raw
static void read_bt_mesh_model_op_raw_struct(erpc::Codec * codec, bt_mesh_model_op_raw * data);

//! @brief Function to read struct bt_mesh_health_srv_raw
static void read_bt_mesh_health_srv_raw_struct(erpc::Codec * codec, bt_mesh_health_srv_raw * data);

//! @brief Function to read struct bt_mesh_health_srv_cb_raw
static void read_bt_mesh_health_srv_cb_raw_struct(erpc::Codec * codec, bt_mesh_health_srv_cb_raw * data);

//! @brief Function to read struct bt_mesh_cfg_mod_pub_raw
static void read_bt_mesh_cfg_mod_pub_raw_struct(erpc::Codec * codec, bt_mesh_cfg_mod_pub_raw * data);

//! @brief Function to read struct bt_mesh_msg_ctx_raw
static void read_bt_mesh_msg_ctx_raw_struct(erpc::Codec * codec, bt_mesh_msg_ctx_raw * data);


// Read struct bt_mesh_prov_raw function implementation
static void read_bt_mesh_prov_raw_struct(erpc::Codec * codec, bt_mesh_prov_raw * data)
{
    bool isNull;
    int32_t _tmp_local;
    uint32_t lengthTemp_0;
    codec->startReadList(&lengthTemp_0);
    data->uuid_len = lengthTemp_0;
    if (lengthTemp_0 > 0)
    {
        data->uuid = (uint8_t *) erpc_malloc(lengthTemp_0 * sizeof(uint8_t));
        if (data->uuid == NULL)
        {
            codec->updateStatus(kErpcStatus_MemoryError);
        }
        for (uint32_t listCount0 = 0; listCount0 < lengthTemp_0; ++listCount0)
        {
            codec->read(&data->uuid[listCount0]);
        }
    }
    else
    {
        data->uuid = NULL;
    }

    uint32_t uri_len;
    char * uri_local;
    codec->readString(&uri_len, &uri_local);
    data->uri = (char *) erpc_malloc((uri_len + 1) * sizeof(char));
    if (data->uri == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    else
    {
        memcpy(data->uri, uri_local, uri_len);
        (data->uri)[uri_len] = 0;
    }

    codec->read(&_tmp_local);
    data->oob_info = static_cast<bt_mesh_prov_oob_info>(_tmp_local);

    codec->readNullFlag(&isNull);
    if (!isNull)
    {
        uint32_t lengthTemp_1;
        codec->startReadList(&lengthTemp_1);
        data->static_val_len = lengthTemp_1;
        if (lengthTemp_1 > 0)
        {
            data->static_val = (uint8_t *) erpc_malloc(lengthTemp_1 * sizeof(uint8_t));
            if (data->static_val == NULL)
            {
                codec->updateStatus(kErpcStatus_MemoryError);
            }
            for (uint32_t listCount1 = 0; listCount1 < lengthTemp_1; ++listCount1)
            {
                codec->read(&data->static_val[listCount1]);
            }
        }
        else
        {
            data->static_val = NULL;
        }
    }
    else
    {
        data->static_val = NULL;
    }

    codec->read(&data->output_size);

    codec->read(&data->output_actions);

    codec->read(&data->input_size);

    codec->read(&data->input_actions);

    codec->readNullFlag(&isNull);
    if (!isNull)
    {
        codec->readCallback((funPtr)(output_number_cb), (funPtr *)(&data->output_number));
    }
    else
    {
        data->output_number = NULL;
    }

    codec->readNullFlag(&isNull);
    if (!isNull)
    {
        codec->readCallback((funPtr)(output_string_cb), (funPtr *)(&data->output_string));
    }
    else
    {
        data->output_string = NULL;
    }

    codec->readNullFlag(&isNull);
    if (!isNull)
    {
        codec->readCallback((funPtr)(input_cb), (funPtr *)(&data->input));
    }
    else
    {
        data->input = NULL;
    }

    codec->readNullFlag(&isNull);
    if (!isNull)
    {
        codec->readCallback((funPtr)(input_complete_cb), (funPtr *)(&data->input_complete));
    }
    else
    {
        data->input_complete = NULL;
    }

    codec->readNullFlag(&isNull);
    if (!isNull)
    {
        codec->readCallback((funPtr)(unprovisioned_beacon_cb), (funPtr *)(&data->unprovisioned_beacon));
    }
    else
    {
        data->unprovisioned_beacon = NULL;
    }

    codec->readNullFlag(&isNull);
    if (!isNull)
    {
        codec->readCallback((funPtr)(link_open_cb), (funPtr *)(&data->link_open));
    }
    else
    {
        data->link_open = NULL;
    }

    codec->readNullFlag(&isNull);
    if (!isNull)
    {
        codec->readCallback((funPtr)(link_close_cb), (funPtr *)(&data->link_close));
    }
    else
    {
        data->link_close = NULL;
    }

    codec->readNullFlag(&isNull);
    if (!isNull)
    {
        codec->readCallback((funPtr)(complete_cb), (funPtr *)(&data->complete));
    }
    else
    {
        data->complete = NULL;
    }

    codec->readNullFlag(&isNull);
    if (!isNull)
    {
        codec->readCallback((funPtr)(node_added_cb), (funPtr *)(&data->node_added));
    }
    else
    {
        data->node_added = NULL;
    }

    codec->readNullFlag(&isNull);
    if (!isNull)
    {
        codec->readCallback((funPtr)(reset_prov_cb), (funPtr *)(&data->reset));
    }
    else
    {
        data->reset = NULL;
    }
}

// Read struct bt_mesh_comp_raw function implementation
static void read_bt_mesh_comp_raw_struct(erpc::Codec * codec, bt_mesh_comp_raw * data)
{
    codec->read(&data->cid);

    codec->read(&data->pid);

    codec->read(&data->vid);

    codec->read(&data->elem_count);

    codec->read(&data->elem_placeholder);
}

// Read struct bt_mesh_elem_raw function implementation
static void read_bt_mesh_elem_raw_struct(erpc::Codec * codec, bt_mesh_elem_raw * data)
{
    codec->read(&data->addr);

    codec->read(&data->loc);

    codec->read(&data->model_count);

    codec->read(&data->vnd_model_count);

    codec->read(&data->models_placeholder);

    codec->read(&data->vnd_models_placeholder);
}

// Read struct bt_mesh_model_pub_raw function implementation
static void read_bt_mesh_model_pub_raw_struct(erpc::Codec * codec, bt_mesh_model_pub_raw * data)
{
    bool isNull;
    codec->read(&data->addr);

    codec->read(&data->key);

    codec->read(&data->ttl);

    codec->read(&data->retransmit);

    codec->read(&data->period);

    codec->read(&data->period_div);

    codec->read(&data->period_start);

    data->msg = (net_buf_simple_raw *) erpc_malloc(sizeof(net_buf_simple_raw));
    if (data->msg == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    read_net_buf_simple_raw_struct(codec, &(*data->msg));

    codec->readNullFlag(&isNull);
    if (!isNull)
    {
        codec->readCallback((funPtr)(update_cb), (funPtr *)(&data->update));
    }
    else
    {
        data->update = NULL;
    }
}

// Read struct net_buf_simple_raw function implementation
static void read_net_buf_simple_raw_struct(erpc::Codec * codec, net_buf_simple_raw * data)
{
    uint32_t lengthTemp_0;
    codec->startReadList(&lengthTemp_0);
    data->len = lengthTemp_0;
    if (lengthTemp_0 > 0)
    {
        data->data = (uint8_t *) erpc_malloc(lengthTemp_0 * sizeof(uint8_t));
        if (data->data == NULL)
        {
            codec->updateStatus(kErpcStatus_MemoryError);
        }
        for (uint32_t listCount0 = 0; listCount0 < lengthTemp_0; ++listCount0)
        {
            codec->read(&data->data[listCount0]);
        }
    }
    else
    {
        data->data = NULL;
    }

    codec->read(&data->size);

    data->__buf = (uint8_t *) erpc_malloc(sizeof(uint8_t));
    if (data->__buf == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    codec->read(&*data->__buf);
}

// Read struct bt_mesh_model_raw function implementation
static void read_bt_mesh_model_raw_struct(erpc::Codec * codec, bt_mesh_model_raw * data)
{
    bool isNull;
    codec->startReadUnion(&data->model_type);
    switch (data->model_type)
    {
        case SIG_MODEL:
        {
            codec->read(&data->model.id);
            break;
        }
        case VND_MODEL:
        {
            codec->read(&data->model.company);
            codec->read(&data->model.vnd_id);
            break;
        }
    }

    codec->readNullFlag(&isNull);
    if (!isNull)
    {
        data->pub = (bt_mesh_model_pub_raw *) erpc_malloc(sizeof(bt_mesh_model_pub_raw));
        if (data->pub == NULL)
        {
            codec->updateStatus(kErpcStatus_MemoryError);
        }
        read_bt_mesh_model_pub_raw_struct(codec, &(*data->pub));
    }
    else
    {
        data->pub = NULL;
    }

    codec->readNullFlag(&isNull);
    if (!isNull)
    {
        data->cb = (bt_mesh_model_cb_raw *) erpc_malloc(sizeof(bt_mesh_model_cb_raw));
        if (data->cb == NULL)
        {
            codec->updateStatus(kErpcStatus_MemoryError);
        }
        read_bt_mesh_model_cb_raw_struct(codec, &(*data->cb));
    }
    else
    {
        data->cb = NULL;
    }

    codec->readNullFlag(&isNull);
    if (!isNull)
    {
        uint32_t user_data_len;
        char * user_data_local;
        codec->readString(&user_data_len, &user_data_local);
        data->user_data = (char *) erpc_malloc((user_data_len + 1) * sizeof(char));
        if (data->user_data == NULL)
        {
            codec->updateStatus(kErpcStatus_MemoryError);
        }
        else
        {
            memcpy(data->user_data, user_data_local, user_data_len);
            (data->user_data)[user_data_len] = 0;
        }
    }
    else
    {
        data->user_data = NULL;
    }
}

// Read struct bt_mesh_model_cb_raw function implementation
static void read_bt_mesh_model_cb_raw_struct(erpc::Codec * codec, bt_mesh_model_cb_raw * data)
{
    bool isNull;
    codec->readNullFlag(&isNull);
    if (!isNull)
    {
        codec->readCallback((funPtr)(settings_set_cb), (funPtr *)(&data->settings_set));
    }
    else
    {
        data->settings_set = NULL;
    }

    codec->readNullFlag(&isNull);
    if (!isNull)
    {
        codec->readCallback((funPtr)(start_cb), (funPtr *)(&data->start));
    }
    else
    {
        data->start = NULL;
    }

    codec->readNullFlag(&isNull);
    if (!isNull)
    {
        codec->readCallback((funPtr)(init_cb), (funPtr *)(&data->init));
    }
    else
    {
        data->init = NULL;
    }

    codec->readNullFlag(&isNull);
    if (!isNull)
    {
        codec->readCallback((funPtr)(reset_cb), (funPtr *)(&data->reset));
    }
    else
    {
        data->reset = NULL;
    }
}

// Read struct bt_mesh_model_op_raw function implementation
static void read_bt_mesh_model_op_raw_struct(erpc::Codec * codec, bt_mesh_model_op_raw * data)
{
    bool isNull;
    codec->read(&data->opcode);

    codec->read(&data->min_len);

    codec->readNullFlag(&isNull);
    if (!isNull)
    {
        codec->readCallback((funPtr)(func_cb), (funPtr *)(&data->func));
    }
    else
    {
        data->func = NULL;
    }
}

// Read struct bt_mesh_health_srv_raw function implementation
static void read_bt_mesh_health_srv_raw_struct(erpc::Codec * codec, bt_mesh_health_srv_raw * data)
{
    codec->read(&data->model_placeholder);

    data->cb = (bt_mesh_health_srv_cb_raw *) erpc_malloc(sizeof(bt_mesh_health_srv_cb_raw));
    if (data->cb == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    read_bt_mesh_health_srv_cb_raw_struct(codec, &(*data->cb));

    codec->read(&data->k_delayed_work_placeholder);
}

// Read struct bt_mesh_health_srv_cb_raw function implementation
static void read_bt_mesh_health_srv_cb_raw_struct(erpc::Codec * codec, bt_mesh_health_srv_cb_raw * data)
{
    codec->readCallback((funPtr)(fault_get_cur_cb), (funPtr *)(&data->fault_get_cur));

    codec->readCallback((funPtr)(fault_get_reg_cb), (funPtr *)(&data->fault_get_reg));

    codec->readCallback((funPtr)(fault_clear_cb), (funPtr *)(&data->fault_clear));

    codec->readCallback((funPtr)(fault_test_cb), (funPtr *)(&data->fault_test));

    codec->readCallback((funPtr)(attn_on_cb), (funPtr *)(&data->attn_on));

    codec->readCallback((funPtr)(attn_off_cb), (funPtr *)(&data->attn_off));
}

// Read struct bt_mesh_cfg_mod_pub_raw function implementation
static void read_bt_mesh_cfg_mod_pub_raw_struct(erpc::Codec * codec, bt_mesh_cfg_mod_pub_raw * data)
{
    codec->read(&data->addr);

    codec->read(&data->app_idx);

    codec->read(&data->cred_flag);

    codec->read(&data->ttl);

    codec->read(&data->period);

    codec->read(&data->transmit);
}

// Read struct bt_mesh_msg_ctx_raw function implementation
static void read_bt_mesh_msg_ctx_raw_struct(erpc::Codec * codec, bt_mesh_msg_ctx_raw * data)
{
    codec->read(&data->net_idx);

    codec->read(&data->app_idx);

    codec->read(&data->addr);

    codec->read(&data->recv_dst);

    codec->read(&data->recv_rssi);

    codec->read(&data->recv_ttl);

    codec->read(&data->send_rel);

    codec->read(&data->send_ttl);
}


//! @brief Function to free space allocated inside struct bt_mesh_prov_raw
static void free_bt_mesh_prov_raw_struct(bt_mesh_prov_raw * data);

//! @brief Function to free space allocated inside struct bt_mesh_model_pub_raw
static void free_bt_mesh_model_pub_raw_struct(bt_mesh_model_pub_raw * data);

//! @brief Function to free space allocated inside struct net_buf_simple_raw
static void free_net_buf_simple_raw_struct(net_buf_simple_raw * data);

//! @brief Function to free space allocated inside struct bt_mesh_model_raw
static void free_bt_mesh_model_raw_struct(bt_mesh_model_raw * data);

//! @brief Function to free space allocated inside struct bt_mesh_health_srv_raw
static void free_bt_mesh_health_srv_raw_struct(bt_mesh_health_srv_raw * data);


// Free space allocated inside struct bt_mesh_prov_raw function implementation
static void free_bt_mesh_prov_raw_struct(bt_mesh_prov_raw * data)
{
    if (data->uuid)
    {
        erpc_free(data->uuid);
    }

    if (data->uri)
    {
        erpc_free(data->uri);
    }

    if (data->static_val) // this is a nullable member
    {
        if (data->static_val)
        {
            erpc_free(data->static_val);
        }
    }
}

// Free space allocated inside struct bt_mesh_model_pub_raw function implementation
static void free_bt_mesh_model_pub_raw_struct(bt_mesh_model_pub_raw * data)
{
    free_net_buf_simple_raw_struct(&*data->msg);
    if (data->msg)
    {
        erpc_free(data->msg);
    }
}

// Free space allocated inside struct net_buf_simple_raw function implementation
static void free_net_buf_simple_raw_struct(net_buf_simple_raw * data)
{
    if (data->data)
    {
        erpc_free(data->data);
    }


    if (data->__buf)
    {
        erpc_free(data->__buf);
    }
}

// Free space allocated inside struct bt_mesh_model_raw function implementation
static void free_bt_mesh_model_raw_struct(bt_mesh_model_raw * data)
{
    if (data->pub) // this is a nullable member
    {
        free_bt_mesh_model_pub_raw_struct(&*data->pub);
    }
    if (data->pub)
    {
        erpc_free(data->pub);
    }

    if (data->cb) // this is a nullable member
    {

    }
    if (data->cb)
    {
        erpc_free(data->cb);
    }

    if (data->user_data) // this is a nullable member
    {
        if (data->user_data)
        {
            erpc_free(data->user_data);
        }
    }
}

// Free space allocated inside struct bt_mesh_health_srv_raw function implementation
static void free_bt_mesh_health_srv_raw_struct(bt_mesh_health_srv_raw * data)
{

    if (data->cb)
    {
        erpc_free(data->cb);
    }
}



// Call the correct server shim based on method unique ID.
erpc_status_t BLEmesh_api_service::handleInvocation(uint32_t methodId, uint32_t sequence, Codec * codec, MessageBufferFactory *messageFactory)
{
    switch (methodId)
    {
#ifndef ERPC_REMOVE__mesh_init
        case kBLEmesh_api_mesh_init_id:
            return mesh_init_shim(codec, messageFactory, sequence);
#endif

#ifndef ERPC_REMOVE__bt_mesh_init_prov_raw_init
        case kBLEmesh_api_bt_mesh_init_prov_raw_init_id:
            return bt_mesh_init_prov_raw_init_shim(codec, messageFactory, sequence);
#endif

#ifndef ERPC_REMOVE__bt_mesh_init_comp_raw_init
        case kBLEmesh_api_bt_mesh_init_comp_raw_init_id:
            return bt_mesh_init_comp_raw_init_shim(codec, messageFactory, sequence);
#endif

#ifndef ERPC_REMOVE__bt_mesh_init_elem_raw_init
        case kBLEmesh_api_bt_mesh_init_elem_raw_init_id:
            return bt_mesh_init_elem_raw_init_shim(codec, messageFactory, sequence);
#endif

#ifndef ERPC_REMOVE__bt_mesh_cfg_cli_raw_init
        case kBLEmesh_api_bt_mesh_cfg_cli_raw_init_id:
            return bt_mesh_cfg_cli_raw_init_shim(codec, messageFactory, sequence);
#endif

#ifndef ERPC_REMOVE__bt_mesh_init_model_raw_init
        case kBLEmesh_api_bt_mesh_init_model_raw_init_id:
            return bt_mesh_init_model_raw_init_shim(codec, messageFactory, sequence);
#endif

#ifndef ERPC_REMOVE__bt_mesh_cfg_srv_raw_init
        case kBLEmesh_api_bt_mesh_cfg_srv_raw_init_id:
            return bt_mesh_cfg_srv_raw_init_shim(codec, messageFactory, sequence);
#endif

#ifndef ERPC_REMOVE__bt_mesh_health_srv_raw_init
        case kBLEmesh_api_bt_mesh_health_srv_raw_init_id:
            return bt_mesh_health_srv_raw_init_shim(codec, messageFactory, sequence);
#endif

#ifndef ERPC_REMOVE__bt_mesh_reset
        case kBLEmesh_api_bt_mesh_reset_id:
            return bt_mesh_reset_shim(codec, messageFactory, sequence);
#endif

#ifndef ERPC_REMOVE__bt_mesh_suspend
        case kBLEmesh_api_bt_mesh_suspend_id:
            return bt_mesh_suspend_shim(codec, messageFactory, sequence);
#endif

#ifndef ERPC_REMOVE__bt_mesh_resume
        case kBLEmesh_api_bt_mesh_resume_id:
            return bt_mesh_resume_shim(codec, messageFactory, sequence);
#endif

#ifndef ERPC_REMOVE__bt_mesh_iv_update_test
        case kBLEmesh_api_bt_mesh_iv_update_test_id:
            return bt_mesh_iv_update_test_shim(codec, messageFactory, sequence);
#endif

#ifndef ERPC_REMOVE__bt_mesh_iv_update
        case kBLEmesh_api_bt_mesh_iv_update_id:
            return bt_mesh_iv_update_shim(codec, messageFactory, sequence);
#endif

#ifndef ERPC_REMOVE__bt_mesh_lpn_set
        case kBLEmesh_api_bt_mesh_lpn_set_id:
            return bt_mesh_lpn_set_shim(codec, messageFactory, sequence);
#endif

#ifndef ERPC_REMOVE__bt_mesh_lpn_poll
        case kBLEmesh_api_bt_mesh_lpn_poll_id:
            return bt_mesh_lpn_poll_shim(codec, messageFactory, sequence);
#endif

#ifndef ERPC_REMOVE__bt_mesh_input_string
        case kBLEmesh_api_bt_mesh_input_string_id:
            return bt_mesh_input_string_shim(codec, messageFactory, sequence);
#endif

#ifndef ERPC_REMOVE__bt_mesh_input_number
        case kBLEmesh_api_bt_mesh_input_number_id:
            return bt_mesh_input_number_shim(codec, messageFactory, sequence);
#endif

#ifndef ERPC_REMOVE__bt_mesh_prov_enable_wrapper
        case kBLEmesh_api_bt_mesh_prov_enable_wrapper_id:
            return bt_mesh_prov_enable_wrapper_shim(codec, messageFactory, sequence);
#endif

#ifndef ERPC_REMOVE__bt_mesh_prov_disable_wrapper
        case kBLEmesh_api_bt_mesh_prov_disable_wrapper_id:
            return bt_mesh_prov_disable_wrapper_shim(codec, messageFactory, sequence);
#endif

#ifndef ERPC_REMOVE__bt_mesh_provision
        case kBLEmesh_api_bt_mesh_provision_id:
            return bt_mesh_provision_shim(codec, messageFactory, sequence);
#endif

#ifndef ERPC_REMOVE__bt_mesh_cfg_app_key_add_wrapper
        case kBLEmesh_api_bt_mesh_cfg_app_key_add_wrapper_id:
            return bt_mesh_cfg_app_key_add_wrapper_shim(codec, messageFactory, sequence);
#endif

#ifndef ERPC_REMOVE__bt_mesh_cfg_mod_app_bind_vnd_wrapper
        case kBLEmesh_api_bt_mesh_cfg_mod_app_bind_vnd_wrapper_id:
            return bt_mesh_cfg_mod_app_bind_vnd_wrapper_shim(codec, messageFactory, sequence);
#endif

#ifndef ERPC_REMOVE__bt_mesh_cfg_mod_app_bind_wrapper
        case kBLEmesh_api_bt_mesh_cfg_mod_app_bind_wrapper_id:
            return bt_mesh_cfg_mod_app_bind_wrapper_shim(codec, messageFactory, sequence);
#endif

#ifndef ERPC_REMOVE__bt_mesh_cfg_mod_sub_add_vnd_wrapper
        case kBLEmesh_api_bt_mesh_cfg_mod_sub_add_vnd_wrapper_id:
            return bt_mesh_cfg_mod_sub_add_vnd_wrapper_shim(codec, messageFactory, sequence);
#endif

#ifndef ERPC_REMOVE__bt_mesh_cfg_mod_sub_add_wrapper
        case kBLEmesh_api_bt_mesh_cfg_mod_sub_add_wrapper_id:
            return bt_mesh_cfg_mod_sub_add_wrapper_shim(codec, messageFactory, sequence);
#endif

#ifndef ERPC_REMOVE__bt_mesh_cfg_mod_sub_del_wrapper
        case kBLEmesh_api_bt_mesh_cfg_mod_sub_del_wrapper_id:
            return bt_mesh_cfg_mod_sub_del_wrapper_shim(codec, messageFactory, sequence);
#endif

#ifndef ERPC_REMOVE__bt_mesh_cfg_mod_sub_del_vnd_wrapper
        case kBLEmesh_api_bt_mesh_cfg_mod_sub_del_vnd_wrapper_id:
            return bt_mesh_cfg_mod_sub_del_vnd_wrapper_shim(codec, messageFactory, sequence);
#endif

#ifndef ERPC_REMOVE__bt_mesh_cfg_mod_sub_va_add_wrapper
        case kBLEmesh_api_bt_mesh_cfg_mod_sub_va_add_wrapper_id:
            return bt_mesh_cfg_mod_sub_va_add_wrapper_shim(codec, messageFactory, sequence);
#endif

#ifndef ERPC_REMOVE__bt_mesh_cfg_mod_sub_va_add_vnd_wrapper
        case kBLEmesh_api_bt_mesh_cfg_mod_sub_va_add_vnd_wrapper_id:
            return bt_mesh_cfg_mod_sub_va_add_vnd_wrapper_shim(codec, messageFactory, sequence);
#endif

#ifndef ERPC_REMOVE__bt_mesh_cfg_mod_pub_set_wrapper
        case kBLEmesh_api_bt_mesh_cfg_mod_pub_set_wrapper_id:
            return bt_mesh_cfg_mod_pub_set_wrapper_shim(codec, messageFactory, sequence);
#endif

#ifndef ERPC_REMOVE__bt_mesh_cfg_mod_pub_set_vnd_wrapper
        case kBLEmesh_api_bt_mesh_cfg_mod_pub_set_vnd_wrapper_id:
            return bt_mesh_cfg_mod_pub_set_vnd_wrapper_shim(codec, messageFactory, sequence);
#endif

#ifndef ERPC_REMOVE__bt_mesh_is_provisioned
        case kBLEmesh_api_bt_mesh_is_provisioned_id:
            return bt_mesh_is_provisioned_shim(codec, messageFactory, sequence);
#endif

#ifndef ERPC_REMOVE__bt_mesh_proxy_identity_enable
        case kBLEmesh_api_bt_mesh_proxy_identity_enable_id:
            return bt_mesh_proxy_identity_enable_shim(codec, messageFactory, sequence);
#endif

#ifndef ERPC_REMOVE__bt_mesh_model_publish_wrapper
        case kBLEmesh_api_bt_mesh_model_publish_wrapper_id:
            return bt_mesh_model_publish_wrapper_shim(codec, messageFactory, sequence);
#endif

#ifndef ERPC_REMOVE__bt_mesh_model_send_data_wrapper
        case kBLEmesh_api_bt_mesh_model_send_data_wrapper_id:
            return bt_mesh_model_send_data_wrapper_shim(codec, messageFactory, sequence);
#endif

#ifndef ERPC_REMOVE__bt_mesh_model_find_wrapper
        case kBLEmesh_api_bt_mesh_model_find_wrapper_id:
            return bt_mesh_model_find_wrapper_shim(codec, messageFactory, sequence);
#endif

#ifndef ERPC_REMOVE__bt_mesh_model_find_vnd_wrapper
        case kBLEmesh_api_bt_mesh_model_find_vnd_wrapper_id:
            return bt_mesh_model_find_vnd_wrapper_shim(codec, messageFactory, sequence);
#endif

#ifndef ERPC_REMOVE__bt_mesh_model_extend_wrapper
        case kBLEmesh_api_bt_mesh_model_extend_wrapper_id:
            return bt_mesh_model_extend_wrapper_shim(codec, messageFactory, sequence);
#endif

#ifndef ERPC_REMOVE__bt_mesh_fault_update_wrapper
        case kBLEmesh_api_bt_mesh_fault_update_wrapper_id:
            return bt_mesh_fault_update_wrapper_shim(codec, messageFactory, sequence);
#endif

#ifndef ERPC_REMOVE__settings_load_wrapper
        case kBLEmesh_api_settings_load_wrapper_id:
            return settings_load_wrapper_shim(codec, messageFactory, sequence);
#endif

#ifndef ERPC_REMOVE__store_data_wrapper
        case kBLEmesh_api_store_data_wrapper_id:
            return store_data_wrapper_shim(codec, messageFactory, sequence);
#endif

        default:
            return kErpcStatus_InvalidArgument;
    }
}

// Server shim for mesh_init of BLEmesh_api interface.
#ifndef ERPC_REMOVE__mesh_init
erpc_status_t BLEmesh_api_service::mesh_init_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = mesh_init();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, kBLEmesh_api_service_id, kBLEmesh_api_mesh_init_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}
#endif

// Server shim for bt_mesh_init_prov_raw_init of BLEmesh_api interface.
#ifndef ERPC_REMOVE__bt_mesh_init_prov_raw_init
erpc_status_t BLEmesh_api_service::bt_mesh_init_prov_raw_init_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    bt_mesh_prov_raw *prov_raw = NULL;
    prov_raw = (bt_mesh_prov_raw *) erpc_malloc(sizeof(bt_mesh_prov_raw));
    if (prov_raw == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    read_bt_mesh_prov_raw_struct(codec, prov_raw);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = bt_mesh_init_prov_raw_init(prov_raw);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, kBLEmesh_api_service_id, kBLEmesh_api_bt_mesh_init_prov_raw_init_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (prov_raw)
    {
        free_bt_mesh_prov_raw_struct(prov_raw);
    }
    if (prov_raw)
    {
        erpc_free(prov_raw);
    }

    return err;
}
#endif

// Server shim for bt_mesh_init_comp_raw_init of BLEmesh_api interface.
#ifndef ERPC_REMOVE__bt_mesh_init_comp_raw_init
erpc_status_t BLEmesh_api_service::bt_mesh_init_comp_raw_init_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    bt_mesh_comp_raw *comp_raw = NULL;
    comp_raw = (bt_mesh_comp_raw *) erpc_malloc(sizeof(bt_mesh_comp_raw));
    if (comp_raw == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    read_bt_mesh_comp_raw_struct(codec, comp_raw);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = bt_mesh_init_comp_raw_init(comp_raw);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, kBLEmesh_api_service_id, kBLEmesh_api_bt_mesh_init_comp_raw_init_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (comp_raw)
    {
        erpc_free(comp_raw);
    }

    return err;
}
#endif

// Server shim for bt_mesh_init_elem_raw_init of BLEmesh_api interface.
#ifndef ERPC_REMOVE__bt_mesh_init_elem_raw_init
erpc_status_t BLEmesh_api_service::bt_mesh_init_elem_raw_init_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint16_t elem_index;
    bt_mesh_elem_raw *elem_raw = NULL;
    elem_raw = (bt_mesh_elem_raw *) erpc_malloc(sizeof(bt_mesh_elem_raw));
    if (elem_raw == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&elem_index);

    read_bt_mesh_elem_raw_struct(codec, elem_raw);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = bt_mesh_init_elem_raw_init(elem_index, elem_raw);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, kBLEmesh_api_service_id, kBLEmesh_api_bt_mesh_init_elem_raw_init_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (elem_raw)
    {
        erpc_free(elem_raw);
    }

    return err;
}
#endif

// Server shim for bt_mesh_cfg_cli_raw_init of BLEmesh_api interface.
#ifndef ERPC_REMOVE__bt_mesh_cfg_cli_raw_init
erpc_status_t BLEmesh_api_service::bt_mesh_cfg_cli_raw_init_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint16_t elem_index;
    uint16_t model_index;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&elem_index);

    codec->read(&model_index);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = bt_mesh_cfg_cli_raw_init(elem_index, model_index);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, kBLEmesh_api_service_id, kBLEmesh_api_bt_mesh_cfg_cli_raw_init_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}
#endif

// Server shim for bt_mesh_init_model_raw_init of BLEmesh_api interface.
#ifndef ERPC_REMOVE__bt_mesh_init_model_raw_init
erpc_status_t BLEmesh_api_service::bt_mesh_init_model_raw_init_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint16_t elem_index;
    uint16_t model_index;
    bt_mesh_model_raw *model_raw = NULL;
    model_raw = (bt_mesh_model_raw *) erpc_malloc(sizeof(bt_mesh_model_raw));
    if (model_raw == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    bt_mesh_model_op_raw * op_raw = NULL;
    uint16_t op_len;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&elem_index);

    codec->read(&model_index);

    read_bt_mesh_model_raw_struct(codec, model_raw);

    uint32_t lengthTemp_0;
    codec->startReadList(&lengthTemp_0);
    op_len = lengthTemp_0;
    if (lengthTemp_0 > 0)
    {
        op_raw = (bt_mesh_model_op_raw *) erpc_malloc(lengthTemp_0 * sizeof(bt_mesh_model_op_raw));
        if (op_raw == NULL)
        {
            codec->updateStatus(kErpcStatus_MemoryError);
        }
        for (uint32_t listCount0 = 0; listCount0 < lengthTemp_0; ++listCount0)
        {
            read_bt_mesh_model_op_raw_struct(codec, &(op_raw[listCount0]));
        }
    }
    else
    {
        op_raw = NULL;
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = bt_mesh_init_model_raw_init(elem_index, model_index, model_raw, op_raw, op_len);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, kBLEmesh_api_service_id, kBLEmesh_api_bt_mesh_init_model_raw_init_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (model_raw)
    {
        free_bt_mesh_model_raw_struct(model_raw);
    }
    if (model_raw)
    {
        erpc_free(model_raw);
    }

    if (op_raw)
    {
        erpc_free(op_raw);
    }

    return err;
}
#endif

// Server shim for bt_mesh_cfg_srv_raw_init of BLEmesh_api interface.
#ifndef ERPC_REMOVE__bt_mesh_cfg_srv_raw_init
erpc_status_t BLEmesh_api_service::bt_mesh_cfg_srv_raw_init_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint16_t elem_index;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&elem_index);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = bt_mesh_cfg_srv_raw_init(elem_index);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, kBLEmesh_api_service_id, kBLEmesh_api_bt_mesh_cfg_srv_raw_init_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}
#endif

// Server shim for bt_mesh_health_srv_raw_init of BLEmesh_api interface.
#ifndef ERPC_REMOVE__bt_mesh_health_srv_raw_init
erpc_status_t BLEmesh_api_service::bt_mesh_health_srv_raw_init_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint16_t elem_index;
    uint16_t model_index;
    bt_mesh_health_srv_raw *health_srv = NULL;
    health_srv = (bt_mesh_health_srv_raw *) erpc_malloc(sizeof(bt_mesh_health_srv_raw));
    if (health_srv == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    uint8_t max_faults;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&elem_index);

    codec->read(&model_index);

    read_bt_mesh_health_srv_raw_struct(codec, health_srv);

    codec->read(&max_faults);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = bt_mesh_health_srv_raw_init(elem_index, model_index, health_srv, max_faults);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, kBLEmesh_api_service_id, kBLEmesh_api_bt_mesh_health_srv_raw_init_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (health_srv)
    {
        free_bt_mesh_health_srv_raw_struct(health_srv);
    }
    if (health_srv)
    {
        erpc_free(health_srv);
    }

    return err;
}
#endif

// Server shim for bt_mesh_reset of BLEmesh_api interface.
#ifndef ERPC_REMOVE__bt_mesh_reset
erpc_status_t BLEmesh_api_service::bt_mesh_reset_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;


    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        bt_mesh_reset();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, kBLEmesh_api_service_id, kBLEmesh_api_bt_mesh_reset_id, sequence);

        err = codec->getStatus();
    }

    return err;
}
#endif

// Server shim for bt_mesh_suspend of BLEmesh_api interface.
#ifndef ERPC_REMOVE__bt_mesh_suspend
erpc_status_t BLEmesh_api_service::bt_mesh_suspend_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = bt_mesh_suspend();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, kBLEmesh_api_service_id, kBLEmesh_api_bt_mesh_suspend_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}
#endif

// Server shim for bt_mesh_resume of BLEmesh_api interface.
#ifndef ERPC_REMOVE__bt_mesh_resume
erpc_status_t BLEmesh_api_service::bt_mesh_resume_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = bt_mesh_resume();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, kBLEmesh_api_service_id, kBLEmesh_api_bt_mesh_resume_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}
#endif

// Server shim for bt_mesh_iv_update_test of BLEmesh_api interface.
#ifndef ERPC_REMOVE__bt_mesh_iv_update_test
erpc_status_t BLEmesh_api_service::bt_mesh_iv_update_test_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    bool enable;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&enable);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        bt_mesh_iv_update_test(enable);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, kBLEmesh_api_service_id, kBLEmesh_api_bt_mesh_iv_update_test_id, sequence);

        err = codec->getStatus();
    }

    return err;
}
#endif

// Server shim for bt_mesh_iv_update of BLEmesh_api interface.
#ifndef ERPC_REMOVE__bt_mesh_iv_update
erpc_status_t BLEmesh_api_service::bt_mesh_iv_update_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    bool result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = bt_mesh_iv_update();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, kBLEmesh_api_service_id, kBLEmesh_api_bt_mesh_iv_update_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}
#endif

// Server shim for bt_mesh_lpn_set of BLEmesh_api interface.
#ifndef ERPC_REMOVE__bt_mesh_lpn_set
erpc_status_t BLEmesh_api_service::bt_mesh_lpn_set_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    bool enable;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&enable);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = bt_mesh_lpn_set(enable);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, kBLEmesh_api_service_id, kBLEmesh_api_bt_mesh_lpn_set_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}
#endif

// Server shim for bt_mesh_lpn_poll of BLEmesh_api interface.
#ifndef ERPC_REMOVE__bt_mesh_lpn_poll
erpc_status_t BLEmesh_api_service::bt_mesh_lpn_poll_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = bt_mesh_lpn_poll();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, kBLEmesh_api_service_id, kBLEmesh_api_bt_mesh_lpn_poll_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}
#endif

// Server shim for bt_mesh_input_string of BLEmesh_api interface.
#ifndef ERPC_REMOVE__bt_mesh_input_string
erpc_status_t BLEmesh_api_service::bt_mesh_input_string_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    char * str = NULL;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    uint32_t str_len;
    char * str_local;
    codec->readString(&str_len, &str_local);
    str = (char *) erpc_malloc((str_len + 1) * sizeof(char));
    if (str == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    else
    {
        memcpy(str, str_local, str_len);
        (str)[str_len] = 0;
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = bt_mesh_input_string(str);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, kBLEmesh_api_service_id, kBLEmesh_api_bt_mesh_input_string_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (str)
    {
        erpc_free(str);
    }

    return err;
}
#endif

// Server shim for bt_mesh_input_number of BLEmesh_api interface.
#ifndef ERPC_REMOVE__bt_mesh_input_number
erpc_status_t BLEmesh_api_service::bt_mesh_input_number_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t num;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&num);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = bt_mesh_input_number(num);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, kBLEmesh_api_service_id, kBLEmesh_api_bt_mesh_input_number_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}
#endif

// Server shim for bt_mesh_prov_enable_wrapper of BLEmesh_api interface.
#ifndef ERPC_REMOVE__bt_mesh_prov_enable_wrapper
erpc_status_t BLEmesh_api_service::bt_mesh_prov_enable_wrapper_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    bt_mesh_prov_bearer bearers;
    int32_t _tmp_local;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&_tmp_local);
    bearers = static_cast<bt_mesh_prov_bearer>(_tmp_local);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = bt_mesh_prov_enable_wrapper(bearers);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, kBLEmesh_api_service_id, kBLEmesh_api_bt_mesh_prov_enable_wrapper_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}
#endif

// Server shim for bt_mesh_prov_disable_wrapper of BLEmesh_api interface.
#ifndef ERPC_REMOVE__bt_mesh_prov_disable_wrapper
erpc_status_t BLEmesh_api_service::bt_mesh_prov_disable_wrapper_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    bt_mesh_prov_bearer bearers;
    int32_t _tmp_local;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&_tmp_local);
    bearers = static_cast<bt_mesh_prov_bearer>(_tmp_local);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = bt_mesh_prov_disable_wrapper(bearers);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, kBLEmesh_api_service_id, kBLEmesh_api_bt_mesh_prov_disable_wrapper_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}
#endif

// Server shim for bt_mesh_provision of BLEmesh_api interface.
#ifndef ERPC_REMOVE__bt_mesh_provision
erpc_status_t BLEmesh_api_service::bt_mesh_provision_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t net_key[16];
    uint16_t net_idx;
    uint8_t flags;
    uint32_t iv_index;
    uint16_t addr;
    uint8_t dev_key[16];
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    for (uint32_t arrayCount0 = 0; arrayCount0 < 16; ++arrayCount0)
    {
        codec->read(&net_key[arrayCount0]);
    }

    codec->read(&net_idx);

    codec->read(&flags);

    codec->read(&iv_index);

    codec->read(&addr);

    for (uint32_t arrayCount0 = 0; arrayCount0 < 16; ++arrayCount0)
    {
        codec->read(&dev_key[arrayCount0]);
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = bt_mesh_provision(net_key, net_idx, flags, iv_index, addr, dev_key);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, kBLEmesh_api_service_id, kBLEmesh_api_bt_mesh_provision_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}
#endif

// Server shim for bt_mesh_cfg_app_key_add_wrapper of BLEmesh_api interface.
#ifndef ERPC_REMOVE__bt_mesh_cfg_app_key_add_wrapper
erpc_status_t BLEmesh_api_service::bt_mesh_cfg_app_key_add_wrapper_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint16_t net_idx;
    uint16_t addr;
    uint16_t key_net_idx;
    uint16_t key_app_idx;
    uint8_t app_key[16];
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&net_idx);

    codec->read(&addr);

    codec->read(&key_net_idx);

    codec->read(&key_app_idx);

    for (uint32_t arrayCount0 = 0; arrayCount0 < 16; ++arrayCount0)
    {
        codec->read(&app_key[arrayCount0]);
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = bt_mesh_cfg_app_key_add_wrapper(net_idx, addr, key_net_idx, key_app_idx, app_key);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, kBLEmesh_api_service_id, kBLEmesh_api_bt_mesh_cfg_app_key_add_wrapper_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}
#endif

// Server shim for bt_mesh_cfg_mod_app_bind_vnd_wrapper of BLEmesh_api interface.
#ifndef ERPC_REMOVE__bt_mesh_cfg_mod_app_bind_vnd_wrapper
erpc_status_t BLEmesh_api_service::bt_mesh_cfg_mod_app_bind_vnd_wrapper_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint16_t net_idx;
    uint16_t addr;
    uint16_t elem_addr;
    uint16_t mod_app_idx;
    uint16_t mod_id;
    uint16_t cid;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&net_idx);

    codec->read(&addr);

    codec->read(&elem_addr);

    codec->read(&mod_app_idx);

    codec->read(&mod_id);

    codec->read(&cid);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = bt_mesh_cfg_mod_app_bind_vnd_wrapper(net_idx, addr, elem_addr, mod_app_idx, mod_id, cid);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, kBLEmesh_api_service_id, kBLEmesh_api_bt_mesh_cfg_mod_app_bind_vnd_wrapper_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}
#endif

// Server shim for bt_mesh_cfg_mod_app_bind_wrapper of BLEmesh_api interface.
#ifndef ERPC_REMOVE__bt_mesh_cfg_mod_app_bind_wrapper
erpc_status_t BLEmesh_api_service::bt_mesh_cfg_mod_app_bind_wrapper_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint16_t net_idx;
    uint16_t addr;
    uint16_t elem_addr;
    uint16_t mod_app_idx;
    uint16_t mod_id;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&net_idx);

    codec->read(&addr);

    codec->read(&elem_addr);

    codec->read(&mod_app_idx);

    codec->read(&mod_id);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = bt_mesh_cfg_mod_app_bind_wrapper(net_idx, addr, elem_addr, mod_app_idx, mod_id);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, kBLEmesh_api_service_id, kBLEmesh_api_bt_mesh_cfg_mod_app_bind_wrapper_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}
#endif

// Server shim for bt_mesh_cfg_mod_sub_add_vnd_wrapper of BLEmesh_api interface.
#ifndef ERPC_REMOVE__bt_mesh_cfg_mod_sub_add_vnd_wrapper
erpc_status_t BLEmesh_api_service::bt_mesh_cfg_mod_sub_add_vnd_wrapper_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint16_t net_idx;
    uint16_t addr;
    uint16_t elem_addr;
    uint16_t sub_addr;
    uint16_t mod_id;
    uint16_t cid;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&net_idx);

    codec->read(&addr);

    codec->read(&elem_addr);

    codec->read(&sub_addr);

    codec->read(&mod_id);

    codec->read(&cid);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = bt_mesh_cfg_mod_sub_add_vnd_wrapper(net_idx, addr, elem_addr, sub_addr, mod_id, cid);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, kBLEmesh_api_service_id, kBLEmesh_api_bt_mesh_cfg_mod_sub_add_vnd_wrapper_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}
#endif

// Server shim for bt_mesh_cfg_mod_sub_add_wrapper of BLEmesh_api interface.
#ifndef ERPC_REMOVE__bt_mesh_cfg_mod_sub_add_wrapper
erpc_status_t BLEmesh_api_service::bt_mesh_cfg_mod_sub_add_wrapper_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint16_t net_idx;
    uint16_t addr;
    uint16_t elem_addr;
    uint16_t sub_addr;
    uint16_t mod_id;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&net_idx);

    codec->read(&addr);

    codec->read(&elem_addr);

    codec->read(&sub_addr);

    codec->read(&mod_id);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = bt_mesh_cfg_mod_sub_add_wrapper(net_idx, addr, elem_addr, sub_addr, mod_id);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, kBLEmesh_api_service_id, kBLEmesh_api_bt_mesh_cfg_mod_sub_add_wrapper_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}
#endif

// Server shim for bt_mesh_cfg_mod_sub_del_wrapper of BLEmesh_api interface.
#ifndef ERPC_REMOVE__bt_mesh_cfg_mod_sub_del_wrapper
erpc_status_t BLEmesh_api_service::bt_mesh_cfg_mod_sub_del_wrapper_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint16_t net_idx;
    uint16_t addr;
    uint16_t elem_addr;
    uint16_t sub_addr;
    uint16_t mod_id;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&net_idx);

    codec->read(&addr);

    codec->read(&elem_addr);

    codec->read(&sub_addr);

    codec->read(&mod_id);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = bt_mesh_cfg_mod_sub_del_wrapper(net_idx, addr, elem_addr, sub_addr, mod_id);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, kBLEmesh_api_service_id, kBLEmesh_api_bt_mesh_cfg_mod_sub_del_wrapper_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}
#endif

// Server shim for bt_mesh_cfg_mod_sub_del_vnd_wrapper of BLEmesh_api interface.
#ifndef ERPC_REMOVE__bt_mesh_cfg_mod_sub_del_vnd_wrapper
erpc_status_t BLEmesh_api_service::bt_mesh_cfg_mod_sub_del_vnd_wrapper_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint16_t net_idx;
    uint16_t addr;
    uint16_t elem_addr;
    uint16_t sub_addr;
    uint16_t mod_id;
    uint16_t cid;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&net_idx);

    codec->read(&addr);

    codec->read(&elem_addr);

    codec->read(&sub_addr);

    codec->read(&mod_id);

    codec->read(&cid);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = bt_mesh_cfg_mod_sub_del_vnd_wrapper(net_idx, addr, elem_addr, sub_addr, mod_id, cid);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, kBLEmesh_api_service_id, kBLEmesh_api_bt_mesh_cfg_mod_sub_del_vnd_wrapper_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}
#endif

// Server shim for bt_mesh_cfg_mod_sub_va_add_wrapper of BLEmesh_api interface.
#ifndef ERPC_REMOVE__bt_mesh_cfg_mod_sub_va_add_wrapper
erpc_status_t BLEmesh_api_service::bt_mesh_cfg_mod_sub_va_add_wrapper_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint16_t net_idx;
    uint16_t addr;
    uint16_t elem_addr;
    uint8_t label[16];
    uint16_t mod_id;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&net_idx);

    codec->read(&addr);

    codec->read(&elem_addr);

    for (uint32_t arrayCount0 = 0; arrayCount0 < 16; ++arrayCount0)
    {
        codec->read(&label[arrayCount0]);
    }

    codec->read(&mod_id);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = bt_mesh_cfg_mod_sub_va_add_wrapper(net_idx, addr, elem_addr, label, mod_id);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, kBLEmesh_api_service_id, kBLEmesh_api_bt_mesh_cfg_mod_sub_va_add_wrapper_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}
#endif

// Server shim for bt_mesh_cfg_mod_sub_va_add_vnd_wrapper of BLEmesh_api interface.
#ifndef ERPC_REMOVE__bt_mesh_cfg_mod_sub_va_add_vnd_wrapper
erpc_status_t BLEmesh_api_service::bt_mesh_cfg_mod_sub_va_add_vnd_wrapper_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint16_t net_idx;
    uint16_t addr;
    uint16_t elem_addr;
    uint8_t label[16];
    uint16_t mod_id;
    uint16_t cid;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&net_idx);

    codec->read(&addr);

    codec->read(&elem_addr);

    for (uint32_t arrayCount0 = 0; arrayCount0 < 16; ++arrayCount0)
    {
        codec->read(&label[arrayCount0]);
    }

    codec->read(&mod_id);

    codec->read(&cid);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = bt_mesh_cfg_mod_sub_va_add_vnd_wrapper(net_idx, addr, elem_addr, label, mod_id, cid);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, kBLEmesh_api_service_id, kBLEmesh_api_bt_mesh_cfg_mod_sub_va_add_vnd_wrapper_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}
#endif

// Server shim for bt_mesh_cfg_mod_pub_set_wrapper of BLEmesh_api interface.
#ifndef ERPC_REMOVE__bt_mesh_cfg_mod_pub_set_wrapper
erpc_status_t BLEmesh_api_service::bt_mesh_cfg_mod_pub_set_wrapper_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint16_t net_idx;
    uint16_t addr;
    uint16_t elem_addr;
    uint16_t mod_id;
    bt_mesh_cfg_mod_pub_raw *pub = NULL;
    pub = (bt_mesh_cfg_mod_pub_raw *) erpc_malloc(sizeof(bt_mesh_cfg_mod_pub_raw));
    if (pub == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&net_idx);

    codec->read(&addr);

    codec->read(&elem_addr);

    codec->read(&mod_id);

    read_bt_mesh_cfg_mod_pub_raw_struct(codec, pub);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = bt_mesh_cfg_mod_pub_set_wrapper(net_idx, addr, elem_addr, mod_id, pub);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, kBLEmesh_api_service_id, kBLEmesh_api_bt_mesh_cfg_mod_pub_set_wrapper_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (pub)
    {
        erpc_free(pub);
    }

    return err;
}
#endif

// Server shim for bt_mesh_cfg_mod_pub_set_vnd_wrapper of BLEmesh_api interface.
#ifndef ERPC_REMOVE__bt_mesh_cfg_mod_pub_set_vnd_wrapper
erpc_status_t BLEmesh_api_service::bt_mesh_cfg_mod_pub_set_vnd_wrapper_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint16_t net_idx;
    uint16_t addr;
    uint16_t elem_addr;
    uint16_t mod_id;
    uint16_t cid;
    bt_mesh_cfg_mod_pub_raw *pub = NULL;
    pub = (bt_mesh_cfg_mod_pub_raw *) erpc_malloc(sizeof(bt_mesh_cfg_mod_pub_raw));
    if (pub == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&net_idx);

    codec->read(&addr);

    codec->read(&elem_addr);

    codec->read(&mod_id);

    codec->read(&cid);

    read_bt_mesh_cfg_mod_pub_raw_struct(codec, pub);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = bt_mesh_cfg_mod_pub_set_vnd_wrapper(net_idx, addr, elem_addr, mod_id, cid, pub);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, kBLEmesh_api_service_id, kBLEmesh_api_bt_mesh_cfg_mod_pub_set_vnd_wrapper_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (pub)
    {
        erpc_free(pub);
    }

    return err;
}
#endif

// Server shim for bt_mesh_is_provisioned of BLEmesh_api interface.
#ifndef ERPC_REMOVE__bt_mesh_is_provisioned
erpc_status_t BLEmesh_api_service::bt_mesh_is_provisioned_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    bool result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = bt_mesh_is_provisioned();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, kBLEmesh_api_service_id, kBLEmesh_api_bt_mesh_is_provisioned_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}
#endif

// Server shim for bt_mesh_proxy_identity_enable of BLEmesh_api interface.
#ifndef ERPC_REMOVE__bt_mesh_proxy_identity_enable
erpc_status_t BLEmesh_api_service::bt_mesh_proxy_identity_enable_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = bt_mesh_proxy_identity_enable();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, kBLEmesh_api_service_id, kBLEmesh_api_bt_mesh_proxy_identity_enable_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}
#endif

// Server shim for bt_mesh_model_publish_wrapper of BLEmesh_api interface.
#ifndef ERPC_REMOVE__bt_mesh_model_publish_wrapper
erpc_status_t BLEmesh_api_service::bt_mesh_model_publish_wrapper_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint16_t elem_idx;
    uint8_t is_vnd;
    uint16_t model_index;
    net_buf_simple_raw *msg = NULL;
    msg = (net_buf_simple_raw *) erpc_malloc(sizeof(net_buf_simple_raw));
    if (msg == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&elem_idx);

    codec->read(&is_vnd);

    codec->read(&model_index);

    read_net_buf_simple_raw_struct(codec, msg);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = bt_mesh_model_publish_wrapper(elem_idx, is_vnd, model_index, msg);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, kBLEmesh_api_service_id, kBLEmesh_api_bt_mesh_model_publish_wrapper_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (msg)
    {
        free_net_buf_simple_raw_struct(msg);
    }
    if (msg)
    {
        erpc_free(msg);
    }

    return err;
}
#endif

// Server shim for bt_mesh_model_send_data_wrapper of BLEmesh_api interface.
#ifndef ERPC_REMOVE__bt_mesh_model_send_data_wrapper
erpc_status_t BLEmesh_api_service::bt_mesh_model_send_data_wrapper_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint16_t elem_idx;
    uint8_t is_vnd;
    uint16_t model_index;
    bt_mesh_msg_ctx_raw *ctx = NULL;
    ctx = (bt_mesh_msg_ctx_raw *) erpc_malloc(sizeof(bt_mesh_msg_ctx_raw));
    if (ctx == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    net_buf_simple_raw *msg = NULL;
    msg = (net_buf_simple_raw *) erpc_malloc(sizeof(net_buf_simple_raw));
    if (msg == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&elem_idx);

    codec->read(&is_vnd);

    codec->read(&model_index);

    read_bt_mesh_msg_ctx_raw_struct(codec, ctx);

    read_net_buf_simple_raw_struct(codec, msg);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = bt_mesh_model_send_data_wrapper(elem_idx, is_vnd, model_index, ctx, msg);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, kBLEmesh_api_service_id, kBLEmesh_api_bt_mesh_model_send_data_wrapper_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (ctx)
    {
        erpc_free(ctx);
    }

    if (msg)
    {
        free_net_buf_simple_raw_struct(msg);
    }
    if (msg)
    {
        erpc_free(msg);
    }

    return err;
}
#endif

// Server shim for bt_mesh_model_find_wrapper of BLEmesh_api interface.
#ifndef ERPC_REMOVE__bt_mesh_model_find_wrapper
erpc_status_t BLEmesh_api_service::bt_mesh_model_find_wrapper_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint16_t elem_idx;
    uint16_t id;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&elem_idx);

    codec->read(&id);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = bt_mesh_model_find_wrapper(elem_idx, id);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, kBLEmesh_api_service_id, kBLEmesh_api_bt_mesh_model_find_wrapper_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}
#endif

// Server shim for bt_mesh_model_find_vnd_wrapper of BLEmesh_api interface.
#ifndef ERPC_REMOVE__bt_mesh_model_find_vnd_wrapper
erpc_status_t BLEmesh_api_service::bt_mesh_model_find_vnd_wrapper_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint16_t elem_idx;
    uint16_t company;
    uint16_t id;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&elem_idx);

    codec->read(&company);

    codec->read(&id);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = bt_mesh_model_find_vnd_wrapper(elem_idx, company, id);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, kBLEmesh_api_service_id, kBLEmesh_api_bt_mesh_model_find_vnd_wrapper_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}
#endif

// Server shim for bt_mesh_model_extend_wrapper of BLEmesh_api interface.
#ifndef ERPC_REMOVE__bt_mesh_model_extend_wrapper
erpc_status_t BLEmesh_api_service::bt_mesh_model_extend_wrapper_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint16_t mod_elem_idx;
    uint8_t mod_is_vnd;
    uint16_t mod_idx;
    uint16_t base_mod_elem_idx;
    uint8_t base_mod_is_vnd;
    uint16_t base_mod_idx;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&mod_elem_idx);

    codec->read(&mod_is_vnd);

    codec->read(&mod_idx);

    codec->read(&base_mod_elem_idx);

    codec->read(&base_mod_is_vnd);

    codec->read(&base_mod_idx);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = bt_mesh_model_extend_wrapper(mod_elem_idx, mod_is_vnd, mod_idx, base_mod_elem_idx, base_mod_is_vnd, base_mod_idx);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, kBLEmesh_api_service_id, kBLEmesh_api_bt_mesh_model_extend_wrapper_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}
#endif

// Server shim for bt_mesh_fault_update_wrapper of BLEmesh_api interface.
#ifndef ERPC_REMOVE__bt_mesh_fault_update_wrapper
erpc_status_t BLEmesh_api_service::bt_mesh_fault_update_wrapper_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint16_t elem_idx;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&elem_idx);

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = bt_mesh_fault_update_wrapper(elem_idx);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, kBLEmesh_api_service_id, kBLEmesh_api_bt_mesh_fault_update_wrapper_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}
#endif

// Server shim for settings_load_wrapper of BLEmesh_api interface.
#ifndef ERPC_REMOVE__settings_load_wrapper
erpc_status_t BLEmesh_api_service::settings_load_wrapper_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = settings_load_wrapper();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, kBLEmesh_api_service_id, kBLEmesh_api_settings_load_wrapper_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}
#endif

// Server shim for store_data_wrapper of BLEmesh_api interface.
#ifndef ERPC_REMOVE__store_data_wrapper
erpc_status_t BLEmesh_api_service::store_data_wrapper_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    uint16_t elem_index;
    uint8_t is_vnd;
    uint16_t model_index;
    char * name = NULL;
    uint8_t data_len;
    uint8_t * data = NULL;
    int32_t result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&elem_index);

    codec->read(&is_vnd);

    codec->read(&model_index);

    uint32_t name_len;
    char * name_local;
    codec->readString(&name_len, &name_local);
    name = (char *) erpc_malloc((name_len + 1) * sizeof(char));
    if (name == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    else
    {
        memcpy(name, name_local, name_len);
        (name)[name_len] = 0;
    }

    uint32_t lengthTemp_0;
    codec->startReadList(&lengthTemp_0);
    data_len = lengthTemp_0;
    if (lengthTemp_0 > 0)
    {
        data = (uint8_t *) erpc_malloc(lengthTemp_0 * sizeof(uint8_t));
        if (data == NULL)
        {
            codec->updateStatus(kErpcStatus_MemoryError);
        }
        for (uint32_t listCount0 = 0; listCount0 < lengthTemp_0; ++listCount0)
        {
            codec->read(&data[listCount0]);
        }
    }
    else
    {
        data = NULL;
    }

    err = codec->getStatus();
    if (!err)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = store_data_wrapper(elem_index, is_vnd, model_index, name, data_len, data);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (!err)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, kBLEmesh_api_service_id, kBLEmesh_api_store_data_wrapper_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (name)
    {
        erpc_free(name);
    }

    if (data)
    {
        erpc_free(data);
    }

    return err;
}
#endif

erpc_service_t create_BLEmesh_api_service()
{
    s_BLEmesh_api_service.construct();
    return s_BLEmesh_api_service.get();
}

void destroy_BLEmesh_api_service()
{
    s_BLEmesh_api_service.destroy();
}
