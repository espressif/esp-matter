from pyradioconfig.calculator_model_framework.CalcManager import CalcManager
from pyradioconfig.calculator_model_framework.model_serializers.human_readable import Human_Readable
from pyradioconfig.calculator_model_framework.model_serializers.static_timestamp_xml import Static_TimeStamp_XML
from pyradioconfig.to_be_deprecated.rm_io import *
from pyradioconfig.unit_tests.utils.phy_calc_helpers import find_all_nonsim_phys
import os.path
import shutil
from git import Repo


def print_phy_h_source_from_regs(phy_name, source_lines, family, append_phy_suffix):

    source_lines.append('void SelectPhy_%s%s_%s_autogen(void);\n' % (phy_name, append_phy_suffix, family))


def print_phy_c_source_from_regs(phy_name, register_dict, source_lines, family, append_phy_suffix):

    source_lines.append('void SelectPhy_%s%s_%s_autogen(void) {' % (phy_name, append_phy_suffix, family))

    # Read the lines of a file into a name/value dictionary
    #
    for register_name in sorted(register_dict.keys()):
        (block, reg) = register_name.split('.')
        value = register_dict[register_name]

        # FW rename for consistency
#        if block == 'RFCRC':
#            block = 'CRC'

        # arrayed register rename for CMSIS TODO:MW
        if reg == 'IRCALCOEFWR0':
            reg = 'IRCALCOEFWR[0].IRCALCOEFWR'
        if reg == 'IRCALCOEFWR1':
            reg = 'IRCALCOEFWR[1].IRCALCOEFWR'
        if reg == 'FCD0':
            reg = 'FCD[0].FCD'
        if reg == 'FCD1':
            reg = 'FCD[1].FCD'
        if reg == 'FCD2':
            reg = 'FCD[2].FCD'
        if reg == 'FCD3':
            reg = 'FCD[3].FCD'

        # don't print sequencer registers for now
        if block == 'SEQ':
            continue

        # Don't print RFCRC
        if block == 'RFCRC':
            continue

        source_lines.append('    %s->%s = 0x%x;' % (block, reg, value))

    source_lines.append('}\n')


def print_phy_c_source_from_regs_expand(phy_name, register_dict, source_lines, family, append_phy_suffix):

    source_lines.append('void SelectPhy_%s%s_%s_autogen(void) {' % (phy_name, append_phy_suffix, family))

    # Read the lines of a file into a name/value dictionary
    #
    for register_name in sorted(register_dict.keys()):
        (block, reg) = register_name.split('.')

#        # FW rename for consistency
#        if block == 'RFCRC':
#            block = 'CRC'

        # arrayed register rename for CMSIS TODO:MW
        reg_shift = reg
        if reg == 'IRCALCOEFWR0':
            reg = 'IRCALCOEFWR[0].IRCALCOEFWR'
#            reg_shift = 'IRCALCOEFWR_IRCALCOEFWR'
        if reg == 'IRCALCOEFWR1':
            reg = 'IRCALCOEFWR[1].IRCALCOEFWR'
            reg_shift = 'IRCALCOEFWR_IRCALCOEFWR'
        if reg == 'FCD0':
            reg = 'FCD[0].FCD'
            reg_shift = 'FCD'
        if reg == 'FCD1':
            reg = 'FCD[1].FCD'
            reg_shift = 'FCD'
        if reg == 'FCD2':
            reg = 'FCD[2].FCD'
            reg_shift = 'FCD'
        if reg == 'FCD3':
            reg = 'FCD[3].FCD'
            reg_shift = 'FCD'

        # don't print sequencer registers for now
        if block == 'SEQ':
            continue

        # Don't print RFCRC registers either
        if block == 'RFCRC':
            continue

        source_lines.append('    %s->%s = %s' % (block, reg, register_dict[register_name]["zzreset"]))

        if block == 'RFFPLL0':
            block = 'RFFPLL'

        if block == 'FEFILT0':
            block = 'FEFILT'

        if block == 'FEFILT1':
            block = 'FEFILT'

        for field in sorted(register_dict[register_name].keys()):
            if field != "zzreset":
                value = register_dict[register_name][field]
                source_lines.append('        | (%s << _%s_%s_%s_SHIFT)' % (value, block, reg_shift, field))

        source_lines.append('        ;')

    source_lines.append('}\n')


#
# This creates a C source file that includes an autogenerated inline
# subroutine for each phy that exists.  Inline code is used because
# the routine is only going to be called once, so an inline function
# won't generate extra code, and an inline function won't generate
# any code at all if it's not called.  An inline function is include
# file friendly.
#
def create_c_source(output_filename_h="efrtest_setup_autogen.h", output_filename_c="efrtest_setup_autogen.c", family="dumbo", phy_list=None, h_format_hack=False):

    # Note that the h_format_hack parameter is used for a workaround where we want to generate the radio_configurator_autogen.h file for the wired FPGA
    # Currently the FPGA does not correctly handle the part-specific .h file and so we need to generate the top level file

    part_family = family
    part_rev = "A0"

    if family.lower() in ["dumbo","jumbo","nerio","nixi","panther","lynx","leopard"]:

        #Use legacy simulation PHY flow
        append_phy_suffix = ""
        radio_configurator = CalcManager(part_family, part_rev)

        if phy_list is None:
            # Get PHYs to filter
            types_model = radio_configurator.create_modem_model_type()
            filter_phy_groups = radio_configurator.get_sim_tests_phy_groups()

            # Filter out phys from list
            filtered_phys = radio_configurator.find_all_phys_of_group_name(types_model, filter_phy_groups)
            phy_list = [x.name for x in filtered_phys]
    else:

        #Use new Sim Target type
        target = "Sim"
        append_phy_suffix = "_sim"
        radio_configurator = CalcManager(part_family, part_rev, target=target)
        if phy_list is None:
            phy_list = find_all_nonsim_phys(part_family, part_rev=part_rev, target=target)

    import pyradioconfig
    repo_path = os.path.abspath(os.path.join(os.path.dirname(pyradioconfig.__file__), "..//..//"))
    repo = Repo(repo_path)
    remote_url = repo.remotes.origin.url  # git config --get remote.origin.url
    remote_hash = repo.head.object.hexsha  # git rev-parse origin

    # Generate the enumerated values for PHY_Select_t
    source_lines_h = []
    if h_format_hack:
        print_h_top_format_hack(source_lines_h, remote_url, remote_hash, part_family)
        for phy_name in sorted(phy_list):
            print_h_typedef_enum_one_phy(source_lines_h, phy_name, '')
        print_h_typedef_enum_end_format_hack(source_lines_h, part_family)
    else:
        print_h_top(source_lines_h, remote_url, remote_hash, part_family)
        for phy_name in sorted(phy_list):
            print_h_typedef_enum_one_phy(source_lines_h, phy_name, append_phy_suffix)
        print_h_typedef_enum_end(source_lines_h, part_family)

    source_lines_c = []
    print_c_top(source_lines_c, remote_url, remote_hash, part_family)
    for phy_name in sorted(phy_list):
        print("Generating C routine: {0}.{1}{2}".format(part_family, phy_name, append_phy_suffix))

        # call calculator to populate model
        model = radio_configurator.calculate_phy(phy_name)

        # Convert from a model to a dictionary of register information
        # and then print the dictionary of registers as source code
        rm = build_rm_object(model.part_family)
        register_dict = model_to_register_dict_expand(model, rm)
        print_phy_h_source_from_regs(phy_name, source_lines_h, part_family, append_phy_suffix)
        print_phy_c_source_from_regs_expand(phy_name, register_dict, source_lines_c, part_family, append_phy_suffix)

    if h_format_hack:
        print_h_bottom_format_hack(source_lines_h)
    else:
        print_h_bottom(source_lines_h)

    # Now print the switch statement to select the appropriate phy
    print_c_switch_top(source_lines_c, part_family)
    for phy_name in sorted(phy_list):
        print_c_switch_one_phy(source_lines_c, phy_name, append_phy_suffix, part_family)
    print_c_switch_bottom(source_lines_c)

    # Write the results to a file
    dir = os.path.dirname(output_filename_h)
    if not os.path.exists(dir):
        os.makedirs(dir)
    if os.path.exists(output_filename_h):
        os.remove(output_filename_h)
    outputfile = open(output_filename_h, 'w')
    for line in source_lines_h:
        outputfile.write('%s\n' % line)
    outputfile.flush()
    outputfile.close()

    # Write the results to a file
    dir = os.path.dirname(output_filename_c)
    if not os.path.exists(dir):
        os.makedirs(dir)
    if os.path.exists(output_filename_c):
        os.remove(output_filename_c)
    outputfile = open(output_filename_c, 'w')
    for line in source_lines_c:
        outputfile.write('%s\n' % line)
    outputfile.flush()
    outputfile.close()

    print("Finished!")

def print_h_top(source_lines_h, remote_url, remote_hash, part_family):

    # Generate the enumerated values for PHY_Select_t
    source_lines_h.append('// Git URL  : %s' % remote_url)
    source_lines_h.append('// Git Hash : %s' % remote_hash)
    source_lines_h.append('')
    source_lines_h.append('#ifndef _RADIO_CONFIG_%s_AUTOGEN_H_' % part_family.upper())
    source_lines_h.append('#define _RADIO_CONFIG_%s_AUTOGEN_H_' % part_family.upper())
    source_lines_h.append('')
    source_lines_h.append('/* superseded by radio_config_autogen.h')
    source_lines_h.append(' * but still needed to create overall PHY list per chip')
    source_lines_h.append('')
    source_lines_h.append('typedef enum {')

def print_h_top_format_hack(source_lines_h, remote_url, remote_hash, part_family):

    # Generate the enumerated values for PHY_Select_t
    source_lines_h.append('// Git URL  : %s' % remote_url)
    source_lines_h.append('// Git Hash : %s' % remote_hash)
    source_lines_h.append('')
    source_lines_h.append('#ifndef _RADIO_CONFIG_AUTOGEN_H_')
    source_lines_h.append('#define _RADIO_CONFIG_AUTOGEN_H_')
    source_lines_h.append('')
    source_lines_h.append('#include "radio_config_sol_autogen.h"')
    source_lines_h.append('#include "pa.h"')
    source_lines_h.append('#include "simctrl.h"')
    source_lines_h.append('#include "efrtest_setup.h"')
    source_lines_h.append('')
    source_lines_h.append('typedef enum {')

def print_h_typedef_enum_one_phy(source_lines_h, phy_name, append_phy_suffix):
    source_lines_h.append('    %s%s,' % (phy_name, append_phy_suffix))

def print_h_typedef_enum_end(source_lines_h, part_family):
    source_lines_h.append('  } PHY_Select_%s_t;' % part_family)
    source_lines_h.append('*/')
    source_lines_h.append('')

def print_h_typedef_enum_end_format_hack(source_lines_h, part_family):
    source_lines_h.append('  } PHY_Select_t;')
    source_lines_h.append('')

def print_h_bottom(source_lines_h):
    source_lines_h.append('#endif')

def print_h_bottom_format_hack(source_lines_h):
    source_lines_h.append(r"""
void EFRTEST_SelectPhy_PHY_reset_default(void);

void EFRTEST_SelectPhy_PHY_print_define(void);

#define EFRTEST_SelectPhy(phySelect) EFRTEST_SelectPhy_string(phySelect)

#define EFRTEST_SelectPhy_string(phySelect) do { \
    \
    /* EFRTEST_SelectPhy_PHY_reset_default(); */ \
    \
    EFRTEST_SelectPhy_PHY_print_define(); \
    \
    FRC->AUTOCG = 0x7; \
    FRC->CGCLKSTOP = 0x0; \
    \
    print_info("Using PHY = %s", #phySelect); \
    \
    SelectPhy_##phySelect##_sim_sol_autogen(); \
    \
    EFRTEST_SetupLO(); \
    \
    /* Setup the PA for the configured band */ \
    RADIO_PAInit_t paInit = { /* Power Amplifier mode */ \
        PA_SEL_2P4_HP,        /* RADIO_PASel_t paSel */ \
        PA_VOLTMODE_VBAT,     /* PARADIO_PAVoltMode_t voltMode */ \
        200,                  /* int16_t power */ \
        0,                    /* int16_t offset */ \
        1,                    /* uint16_t rampTime */ \
    }; \
    RADIO_PA_Init(&paInit); \
    \
    } while (0)
    """)
    source_lines_h.append('#endif')

def print_c_top(source_lines_c, remote_url, remote_hash, part_family):
    source_lines_c.append('// Git URL  : %s' % remote_url)
    source_lines_c.append('// Git Hash : %s' % remote_hash)
    source_lines_c.append('')
    source_lines_c.append('#include \"pg_%s.h\"' % part_family)
    source_lines_c.append('')

    return source_lines_c

def print_c_switch_top(source_lines_c, part_family):
    source_lines_c.append('/* superseded by radio_config_autogen.h')
    source_lines_c.append(' * but still needed to create overall PHY list per chip')
    source_lines_c.append('')
    source_lines_c.append('int EFRTEST_SelectPhy_%s_autogen(PHY_Select_%s_t phySelect) {' % (part_family, part_family))
    source_lines_c.append('    switch (phySelect) {')

def print_c_switch_one_phy(source_lines_c, phy_name, append_phy_suffix, part_family):
    routine_name = 'SelectPhy_' + phy_name + append_phy_suffix + '_' + part_family + '_autogen()'
    source_lines_c.append(
        '        case %s:  %s;  break;' % ((phy_name + append_phy_suffix).ljust(60), routine_name.ljust(80)))

def print_c_switch_bottom(source_lines_c):
    source_lines_c.append('        default:  return -1;')
    source_lines_c.append('    }')
    source_lines_c.append('    return 0;\n}')
    source_lines_c.append('*/')

#
# This creates a C source file that includes an autogenerated inline
# subroutine for each phy that exists.  Inline code is used because
# the routine is only going to be called once, so an inline function
# won't generate extra code, and an inline function won't generate
# any code at all if it's not called.  An inline function is include
# file friendly.
#
def create_one_c_source(output_filename="efrtest_setup_autogen.h", family="dumbo", phy_name='', optional_inputs=None):

    part_family = family
    part_rev = "A0"
    radio_configurator = CalcManager(part_family, part_rev)

    # Generate the enumerated values for PHY_Select_t
    source_lines = []
    source_lines.append('/*')
    source_lines.append('typedef enum {')
    source_lines.append('    %s,' % phy_name)
    source_lines.append('  } PHY_Select_%s_t;' % part_family)
    source_lines.append('*/')

    print("Generating C routine for: %s" % phy_name)

    # call calculator to populate model
    model = radio_configurator.calculate_phy(phy_name, optional_inputs)

    # Convert from a model to a dictionary of register information
    # and then print the dictionary of registers as source code
    rm = build_rm_object(model.part_family)
    register_dict = model_to_register_dict(model, rm)
    print_phy_c_source_from_regs(phy_name, register_dict, source_lines, part_family, append_phy_suffix="")

    # Now print the switch statement to select the appropriate phy
    source_lines.append('static __INLINE int EFRTEST_SelectPhy_%s_autogen(PHY_Select_%s_t phySelect) {' % (part_family, part_family))
    source_lines.append('    switch (phySelect) {')

    routine_name = 'SelectPhy_' + phy_name + '_' + part_family + '_autogen()'
    source_lines.append('        case %s:  %s;  break;'  % (phy_name.ljust(60), routine_name.ljust(80) ) )
    source_lines.append('        default:  return -1;')
    source_lines.append('    }')
    source_lines.append('    return 0;\n}\n')

    # Write the results to a file
    outputfile = open(output_filename, 'w')
    for line in source_lines:
        outputfile.write('%s\n' % line)
    outputfile.close()

    print("Finished!")

if __name__ == '__main__':
    create_one_c_source('PHY_Bluetooth_LE_2M_Viterbi_BLEIQDSA.h', 'panther', 'PHY_Bluetooth_LE_2M_Viterbi_BLEIQDSA')

    phy_overrides = dict()
    phy_overrides['base_frequency_hz'] = 2450000000  # for BLE
    phy_overrides['RAC_RXENSRCEN_SWRXEN'] = 1
    phy_overrides['MODEM_SYNC0_SYNC0'] = 0xBEEFbed6 #0x8e89bed6
    phy_overrides['FRC_WCNTCMP0_FRAMELENGTH'] = 0x0000001b

    create_one_c_source('PHY_Bluetooth_LE_2M_Viterbi_BLEIQDSA_w_inputs.h', 'panther', 'PHY_Bluetooth_LE_2M_Viterbi_BLEIQDSA', phy_overrides)


    # create_one_c_source('PHY_Bluetooth_LE_Viterbi_BLEIQDSA.h', 'panther', 'PHY_Bluetooth_LE_Viterbi_BLEIQDSA')
    # create_one_c_source('PHY_IEEE802154_2p4GHz_cohdsa.h', 'panther', 'PHY_IEEE802154_2p4GHz_cohdsa')
